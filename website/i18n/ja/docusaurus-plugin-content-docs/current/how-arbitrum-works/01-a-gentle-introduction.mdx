---
title: 優しい入門
description: NitroとArbitrumスタックの基本を学ぶ。
author: dzgoldman
sme: dzgoldman
user_story: As a current or prospective Arbitrum user, I need learn more about Nitros design.
content_type: get-started
---

import ImageWithCaption from '@site/src/components/ImageCaptions/';

このドキュメントは、Arbitrum Nitroの設計とその理由についての詳細な説明です。これはAPIドキュメントでもコードのガイドツアーでもありません。それらを探しているなら他を見てください。「Arbitrum Nitroの内部」は、Nitroの設計を理解したい人のためのものです。

このドキュメントの本文では、Nitro技術の主要な使用例であり、Arbitrum Oneチェーンで使用されているArbitrum Rollupについて説明します。Arbitrum Novaチェーンで使用されているAnyTrustと呼ばれるバリアント使用例もあります。

## なぜArbitrumを使うのか？なぜNitroを使うのか？
ArbitrumはEthereumのためのL2スケーリングソリューションで、独自の利点の組み合わせを提供します。
- 信頼不要のセキュリティ：Ethereumに根ざしたセキュリティで、どのパーティも正しいレイヤー2の結果を保証できます。
- Ethereumとの互換性：修正されていないEVMコントラクトと修正されていないEthereumトランザクションを実行可能
- スケーラビリティ：コントラクトの計算とストレージをメインのEthereumチェーンから移動し、はるかに高いスループットを可能にします。
- 最小コスト：システムの親チェーン（L1）のガスフットプリントを最小限に抑えるように設計およびエンジニアリングされており、トランザクションごとのコストを最小化します。

他のいくつかの子チェーン（L2）システムはこれらの機能の一部を提供しますが、私たちの知る限り、同じコストで同じ機能の組み合わせを提供するシステムは他にありません。

NitroはArbitrumの大規模なアップグレードで、以下を含みます：
- 高度なCalldata圧縮、これにより親チェーン（L1）に投稿されるデータ量を減らし、Arbitrumでのトランザクションコストをさらに削減します。
- 共通実行とフォールト証明のための別々のコンテキスト、これにより親チェーンノードのパフォーマンスが向上し、手数料が低くなります。
- Ethereum L1ガス互換性、EVM操作の価格設定と会計をEthereumと完全に一致させます。
- 追加のL1相互運用性、親ブロック番号との同期を強化し、すべてのEthereum親チェーン（L1）プリコンパイルを完全にサポートします。
- 安全なリトライアブル、リトライアブルチケットが作成されない失敗モードを排除します。
- Gethトレース、より広範なデバッグサポートのために。
- そして、さらに多くの変更があります。

## 全体像
最も基本的なレベルでは、Arbitrumチェーンは次のように動作します：

<ImageWithCaption caption="Original napkin sketch drawn by Arbitrum co-founder Ed Felten" src="https://lh4.googleusercontent.com/qwf_aYyB1AfX9s-_PQysOmPNtWB164_qA6isj3NhkDnmcro6J75f6MC2_AjlN60lpSkSw6DtZwNfrt13F3E_G8jdvjeWHX8EophDA2oUM0mEpPVeTlMbsjUCMmztEM0WvDpyWZ6R" />

ユーザーとコントラクトはメッセージをインボックスに入れます。チェーンはメッセージを一度に1つずつ読み取り、それぞれを処理します。これによりチェーンの状態が更新され、いくつかの出力が生成されます。

Arbitrumチェーンにトランザクションを処理してもらいたい場合、そのトランザクションをチェーンのインボックスに入れる必要があります。そうすれば、チェーンはあなたのトランザクションを見て、それを実行し、いくつかの出力を生成します：トランザクションの受領書と、あなたのトランザクションが開始した引き出しです。

実行は決定論的です -- つまり、チェーンの動作はそのインボックスの内容によって一意に決定されます。このため、あなたのトランザクションがインボックスに入れられた時点で、その結果は知ることができます。どのArbitrumノードも結果を教えてくれます。（そして、あなた自身でArbitrumノードを実行することもできます。）

このドキュメントのすべての技術的詳細はこの図に関連しています。この図からArbitrumの完全な説明に至るには、次のような質問に答える必要があります：
- 誰がインボックス、チェーン状態、および出力を追跡しますか？
- Arbitrumはどのようにしてチェーン状態と出力が正しいことを確認しますか？
- EthereumユーザーとコントラクトはどのようにしてArbitrumとやり取りできますか？
- ArbitrumはEthereum互換のコントラクトとトランザクションをどのようにサポートしますか？
- ETHとトークンはどのようにしてArbitrumチェーンに出入りし、チェーン上でどのように管理されますか？
- 自分自身のArbitrumノードやバリデーターをどのようにして実行できますか？

## Nitroの設計：4つの大きなアイデア
Nitroの本質とその主要な革新は4つの大きなアイデアにあります。ここでそれらを非常に簡単にまとめ、それから後のセクションでより詳細に解説します。

大きなアイデア：シーケンシングと決定論的実行：Nitroは2段階の戦略でトランザクションを処理します。まず、トランザクションを単一の順序付けられたシーケンスに整理し、Nitroはそのシーケンスにコミットします。次に、決定論的な状態遷移関数によってそのシーケンスでトランザクションを処理します。

大きなアイデア：Gethがコアに：Nitroは、人気のあるgo-ethereum（「Geth」）Ethereumノードソフトウェアのコアコードをコンパイルすることで、Ethereumのデータ構造、フォーマット、仮想マシンをサポートします。この方法でGethをライブラリとして使用することで、Ethereumとの非常に高い互換性を確保します。

大きなアイデア：実行と証明の分離：Nitroは同じソースコードを2回コンパイルし、1回はNitroノードでの実行用にネイティブコードに、もう1回は証明用にWASMにコンパイルし、移植性とセキュリティを最適化します。

大きなアイデア：インタラクティブな不正証明を備えた楽観的ロールアップ：Nitroは、Arbitrumが先駆けたインタラクティブな不正証明を含む楽観的ロールアッププロトコルを使用して、親（L1）Ethereumチェーンにトランザクションを決済します。

基礎的な概念、全体像、Arbitrum Nitroの4つの大きなアイデアをカバーしたので、次のセクションではArbitrumプロトコルを通じてトランザクションを追跡する旅を始めます。